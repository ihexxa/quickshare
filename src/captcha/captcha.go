package captcha

import (
	"fmt"
	"image/color"
	"strconv"
	"sync"
	"time"

	"github.com/afocus/captcha"

	"github.com/ihexxa/quickshare/src/idgen/simpleidgen"
)

const batchSize = 4
const cleanThres = 64
const maxAge = 1000000000 * 60 * 3 // 3 min

type CapInfo struct {
	img   *captcha.Image
	value string
}

type SimpleCaptcha struct {
	generator *captcha.Captcha
	store     map[string]*CapInfo
	mtx       *sync.RWMutex
	length    int
	idgen     *simpleidgen.SimpleIDGen
}

func NewSimpleCaptcha(fontPath string, length, width, height int) *SimpleCaptcha {
	generator := captcha.New()
	generator.SetSize(width, height)
	generator.SetDisturbance(captcha.MEDIUM)
	generator.SetFrontColor(color.RGBA{255, 255, 255, 255})
	generator.SetBkgColor(color.RGBA{255, 0, 0, 255}, color.RGBA{0, 0, 255, 255}, color.RGBA{0, 153, 0, 255})

	if err := generator.SetFont(fontPath); err != nil {
		panic(err.Error())
	}

	return &SimpleCaptcha{
		generator: generator,
		store:     map[string]*CapInfo{},
		mtx:       &sync.RWMutex{},
		length:    length,
		idgen:     simpleidgen.New(),
	}
}

func (cap *SimpleCaptcha) GetID() string {
	id := fmt.Sprint(cap.idgen.Gen())
	img, val := cap.generator.Create(cap.length, captcha.ALL)

	cap.mtx.Lock()
	defer cap.mtx.Unlock()

	cap.store[id] = &CapInfo{
		img:   img,
		value: val,
	}
	return id
}

func (cap *SimpleCaptcha) GetImg(id string) (*captcha.Image, bool) {
	cap.mtx.RLock()
	defer cap.mtx.RUnlock()

	info, ok := cap.store[id]

	if !ok {
		return nil, false
	}
	return info.img, true
}

func (cap *SimpleCaptcha) Verify(id, input string) bool {
	cap.mtx.RLock()
	defer cap.mtx.RUnlock()

	if len(cap.store) > cleanThres {
		count := 0
		for id := range cap.store {
			if count > batchSize {
				break
			}

			// all ids are written by myself
			idInt, _ := strconv.ParseUint(id, 10, 64)
			now := time.Now().UnixNano()
			// idInt is originally generated by UnixNano, so it is safe
			if now-int64(idInt) > maxAge {
				delete(cap.store, id)
			}

			count++
		}
	}

	info, ok := cap.store[id]
	delete(cap.store, id)
	return ok && info.value == input
}
